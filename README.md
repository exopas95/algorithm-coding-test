 # 알고리즘 코딩 테스트 준비 - Python

나동빈 저자의 "이것이 취업을 위한 코딩 테스트다"를 기반으로 작성된 문서입니다. 알고리즘에 대한 기본적인 설명은 위 책을 기반으로 기술되었습니다. 

 ## 01. 그리디
단순하지만 강력한 문제 해결 방법으로 어떤 문제가 있을 떄 단순 무식하게, 탐욕적으로 문제를 푸는 알고리즘이다. 여기서 그리디 즉, 탐욕이란 "현재 상황에서 지금 당장 좋은 것만 고르는 방법"을 의미한다.

그리디 알고리즘은 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구하며 현재 상황에서 가장 좋아보이는 것만을 선택해도 문제를 풀 수 있는지를 파악할 수 있어야 한다. 거스름돈 문제가 대표적인 그리디 문제이다.

 ## 02. 구현
 코딩테스트에서 구현이란 '머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정이다. 어떤 문제를 풀든 간에 소스코드를 작성하는 과정은 필수이므로 구현 문제 유형은 모든 범위의 코딩 테스트 문제 유형을 포함하는 개념이다.
 
 그렇다면 어떤 문제가 구현하기 어려운 문제일까? 알고리즘은 간단한데 코드가 지나칠 만큼 길어지는 문제, 특정 소수점 자리까지 출력해야 하는 문제 ,문자열이 입력으로 주어졌을 때 한 문자 단위로 끊어서 리스트에 넣어서 파싱을 해야하는 문제 등이 까다로운 구현 유형의 문제이다. 대체로 사소한 조건 설정이 많은 문제일수록 코드로 구현하기가 까다롭다.
 
 이 책에서 완전탐색과 시뮬레이션 유형을 모두 '구현'유형으로 묶어서 다루고 있다.
 - 완전탐색: 모든 경우의 수를 주저 없이 다 계산하는 해결 방법
 - 시뮬레이션: 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행해야하는 문제 유형
 
 ## 03. DFS/BFS
 DFS/BFS에 앞서서 기초적인 자료구조 스택과 큐, 그리고 재귀 함수에 대해서 알아봐야 한다.
 ### 탐색
 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정
 ### 자료구조
 데이터를 표현하고 관리하고 처리하기 위한 구조로 그중 스택과 큐는 자료구조의 기초개념으로 다음 **삽입(Push)**, **삭제(Pop)**으로 구성된다.
 ### 스택 (Stack)
 박스 쌓기에 비유할 수 있으며, 선입후출 또는 후입선출 구조라고 한다. 예를 들어 앞에서부터 a-b-c 순서로 입력이 됐다면 출력의 순서는 c-b-a의 순서이다. 파이썬에서는 스택을 위해서 별도의 모듈이 필요하지 않는다. 이미 주어진 append()와 pop() 매서드 만으로 스택을 구현할 수 있다.
 ### 큐 (Queue)
 대기 줄에 비유할 수 있으며, 선입선출 구조라고 한다. 예를 들어 a-b-c- 순서로 입력이 됐다면 출력의 순서 또한 a-b-c 이다. 파이썬에서 큐를 사용하기 위해서는 collections 모듈에서 제공하는 deque 자료구조를 활용하자. deque는 스택과 큐의 장점을 모두채택한 것인데 데이터를 넣고 뺴는 속도가 리스트 자료형에 비해 효율적이며 queue 라이브러리를 이용하는 것보다 더 간단하다.
 ### 재귀함수
 자기 자신을 다시 호출하는 함수로 종료 조건을 꼭 명시해줘야 한다. 재귀함수는 수학에서의 점화식을 그대로 표현한 형식이기 때문에 반복문에 비해서 더 간단하다. 
   - n이 0 혹은 1일때: factorial(n) = 1
   - n이 1 보다 클 때: factorial(n) = n * factorial(n - 1)
 ### 그래프
 노드와 엣지로 구조를 표현하는 방법
   - **인접 행렬 방식**: 2차원 행렬에 각 노드가 연결된 형태를 기록하는 방식
   - **인접 리스트 방식**: 연결된 노드에 대한 정보를 차례대로 연결하여 리스트에 기록하는 방식
   - **차이**: 메모리 측면에서 인접행렬 방식은 모든 관계를 저장하므로 노드 개수가 많을수록 메모리가 불필요하게 낭비된다. 반면 인접 리스트는 연결된 정보만을 저장하기에 효율적이다. 하지만 인접 리스트 방식은 특정한 두 노드가 연결되어 있는지에 대한 정보 하나씩 확인해야 되기 때문에 얻는 속도가 느리다. 특정한 노드와 연결된 모든 인접 노드를 순회해야 하는 경우, 인접 리스트 방식이 인접 행렬 방식에 비해 메모리 공간의 낭비가 적다.  
 ### DFS(Depth First Search)
 깊이 우선 탐색이라고 부르며, 그래프에서 깊은 부분을 우선적으로 탐색하는 방법이다.  
   - 스택의 자료구조를 사용한다.
 #### 동작과정
 1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다.
 2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면, 그 노드를 스택에 넣고 방문 처리를 한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.
 3. 2번의 과정을 더 이상 수행할 수 없을 때 까지 반복한다.
```python
# DFS 메서드 정리
def dfs(grapyh, v, visited):
    # 현재 노드를 방문 처리
    visitied[v] = True
  
    # 현재 노드와 연결된 다른 노드를 재귀적으로 방문
    for i in graph[v]:
        if not visitied[i]:
            dfs(graph, i, visited)
```
 ### BFS(Breadth First Search)
 너비 우선 탐색이라고 부르며, 가까운 노드부터 탐색하는 알고리즘이다.
   - 큐 자료구조를 사용한다.
 #### 동작과정
 1. 탐색 시작 노드를 큐에 삽입하고 방문처리를 한다.
 2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리를 한다.
 3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.
 ```python
 # BFS 메서드 정리
 def bfs(graph, start, visitied):
    # 큐(Queue) 구현을 위해 deque 라이브러리 사용
    queue = deque([start])
    
    # 현재 노드를 방문 처리
    visitied[start] = True

    # 큐가 빌 때가지 반복
    while queue:
        # 큐에서 하나의 원소를 뽑기
        v = queue.popleft()
        
        # 해당 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입
        for i in graph[v]:
            if not visitied[i]:
            queue.append(i)
            visitied[i] = True
 ```
 ## 04. 정렬
 정렬이란 데이터를 특정한 기준에 따라서 순서대로 나열하는 것을 말한다. 정렬 알고리즘은 이진 탐색의 전처리 과정으로 내림차순, 혹은 오름차순으로 정렬을 해야 이진 탐색을 적용할 수 있기 때문에 정렬 알고리즘을 잘 아는 것은 매우 중요하다. 여기서는 선택 정렬, 삽입 정렬, 퀵 정렬, 계수 정렬과 함께 파이썬에서 정렬에 어떤 라이브러리를 사용해야하는 지를 다룬다.
 ### 선택 정렬
 **가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복**하는 정렬로 '매번 가장 작은 것을 선택'한다는 의미에서 선택 정렬 알고리즘이라고 한다.
 ```Python
for i in range(len(array)):
    min_index = i

    for j in range(i + 1, len(array)):
        if array[min_index] > array[j]:
            min_index = j
            
    array[i], array[min_index] = array[min_index], array[i]  # 파이썬은 이런 식으로 Swap이 가능
 ```
 #### 선택 정렬의 시간 복잡도
 선택 정렬은 N - 1번 만큼 가장 작은 수를 찾아서 맨 앞으로 보내야 한다. 또한 매번 가장 작은 수를 찾기위해서 비교연산이 필요하다. 따라서 연산 횟수는 N + (N - 1) + (N - 2) + ... + 2로 볼 수 있다. 이것의 근사치는 N * (N + 1) / 2번으로 빅오 표기법으로 간단히 O(N^2)이라고 표현할 수 있다.
 ### 삽입 정렬
 **데이터를 하나씩 확인하며, 각 데이터를 적절한 위치에 삽입하는 방법**으로 선택 정렬에 비해 실행 시간 측면에서 더 효율적인 알고리즘이다. ㅌ특히 필요할 때만 위치를 바꾸기 때문에 '데이터가 거의 정렬되어 있을 때' 훨씬 효율적이다. 삽입 정렬은 항상 올므차순을 유지하고 있으므로 삽입하려는 데이터가 자기보다 작은 데이터를 만났다면, 더이 상 데이터를 살펴볼 피료 없이 그 자리에 삽입하면 된다.
 ```python
 for i in range91, len(array)):
    for j in range(i, 0, -1):   # 인덱스 i부터 1까지 감소하며 반복하는 문법
        if array[j] < array[j - 1]:   # 한 칸씩 왼쪽으로 이동
            array[j], array[j - 1] = array[j - 1], array[j]
        else:   # 자기보다 작은 데이터를 만나면 그 위치에서 멈춤
            break
```
#### 삽입 정렬의 시간 복잡도
삽입 정렬도 반복문이 2번 중첩되어 사용되었기에 시간 복잡도는 O(N^2)이다. 하지만 현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작한다는 점을 기억해야 한다. 따라서 최선의 경우 O(N)의 시간 복잡도를 가진다. 정렬이 거의 되어 있는 상황에는 아래 있는 퀵 정렬보다 더 효율적이기도 하다.
 ### 퀵 정렬
 **기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법**으로 가장 많이 쓰이는 정렬 알고리즘이다. 기준을 설정한 다음 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작한다. 퀵 정렬에서는 *피벗(Pivot)*\이 사용되는데, 큰 숫자와 작은 숫자를 교환할 때, 교환하기 위한 기준을 피벗이라고 한다. 피벗을 설정하고 리스트를 분할하는 방법에 따라 여러 가지 방식으로 퀵 정렬을 구분하는데, 여기서는 가장 댇표적인 분할 장식인 호어 분할(Hoare Partition)방식을 기준으로 퀵 정렬을 설명한다. 
 - 호어 분할 방식: 리스트에서 첫 번째 데이터를 피벗으로 정한다.
 #### 전통적인 퀵 정렬 방식
 ```python
 def quick_sort(array, start, end):
    if start >= end:    # 원소가 1개인 경우 종료
        return
    pivot = start    # 피벗은 첫 번째 원소
    left = start + 1
    right = end

    while left <= right:
        # 피벗보다 큰 데이터를 찾을 때까지 반복
        while left <= end and array[left] <= array[pivot]:
            left += 1
        
        # 피벗보다 작은 데이터를 찾을 때까지 반복
        while right > start and array[right] >= array[pivot]:
            right -= 1

        # 엇갈렸다면 작은 데이터와 피벗을 교체
        if left > right:
            array[right], array[pivot] = array[pivot], array[right]
        
        # 엇갈리지 않았다면 작은 데이터와 큰 데이터를 교체
        else:
            array[left], array[right] = array[right], array[left]
        
    # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
    quick_sort(array, start, right - 1)
    quick_sort(array, right + 1, end)
 ```
 #### 파이썬의 장점을 살린 퀵 정렬 방식
 전통 퀵 정렬의 분할 방식과 조금 다르며 피벗과 데이터를 비교하는 비교 연산 횟수가 증가해서 시간 면에서는 조금 비효율적이다. 하지만 더 직관적이고 기억하기 쉽다는 장점이 있다.
 ```python
 def quick_sort(array):
    # 리스트가 하나 이하의 원소만을 담고 있다면 종료
    if len(array) <= 1:
        return array
    
    pivot = array[0]
    tail = array[1:]

    left_side = [x for x in tail if x <= pivot]
    right_side = [x for x in tail if x > pivot]

    # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬을 수행하고, 전체 리스트를 반환
    return quick_sort(left_side) + [pivot] + quick_sort(right_side)
 ```
 #### 퀵 정렬의 시간 복잡도
 앞서 배운 선택 정렬과 삽입 정렬은 최악의 경우에도 항상 시간 복잡도 O(N^2)을 보장한다. 퀵 정렬의 평균 시간 복잡도는 O(NlogN)이다. 먼저 최선의 경우를 생각해보자. 피벗값의 위치가 변경되어 분할이 일어날 때마다 정확히 왼쪽 리스트와 오른쪽 리스트를 절반씩 분할한다면 데이터의 개수(가로 길이)에 비해 분할하는 횟수(세로 길이)는 약 log~2이다. 데이터가 무작위인 경우 퀵 정렬은 빠르게 동작할 확률이 높지만 만약 데이터가 이미 정렬이 되어있다면 퀵 정렬은 매우 느리게 동작한다. 
 ### 계수 정렬
 계수 정렬 **가장 큰 데이터와 가장 작은 데이터의 범위가 모두 담길 수 있도록 하나의 리스트를 생성한 뒤 데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스의 데이터를 1씩 증가시키면서 정렬하는 방식**이다. 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 알고리즘으로 최악의 경우에도 수행 시간 O(N + K)를 보장한다. 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때만 사용할 수 있으며 데이터의 값이 무한한 범위를 가질 수 있는 실수형 데이터가 주어지는 경우 계수 정렬은 사용하기 어렵다. 또한 일반적으로 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않을 때 효과적으로 사용할 수 있다.
 ```python
# 모든 원소의 값이 0보다 크거나 같다고 가정
# 모든 범위를 포함하는 리스트 선언(모든 값은 0으로 초기화)
count = [0] * (max(array) + 1)

for i in range(len(array)):
    count[array[i]] += 1

for i in range(len(count)):
    for j in range(count[i]):
        print(i, end= ' ')
 ```
 #### 계수 정렬의 시간 복잡도
 데이터의 개수를 N, 데이터 중 최댓값의 크기를 K라고 할 때, 계수 정렬의 시간 복잡도는 O(N + K)이다. 데이터의 범위만 한정되어 있다면 효과적으로 사용할 수 있으며 항상 빠르게 동작한다. 현존하는 정렬 알고리즘 중에서 기수 정렬(Radix Sort)와 더불어 가장 빠르다. 
 
 #### 계수 정렬의 공간 복잡도
 계수 정렬은 상황에 따라 심각한 비효율성을 초래한다. 예를 들어 데이터가 0과 999,999 단 2개만 존재할 경우 리스트의 크기가 100만개가 되도록 선언해야 한다. 따라서 항상 사용할 수 있는 정렬 알고리즘은 아니며, 동일한 값을 가지는 데이터가 여러 개 등장할 때 적합하다.
 다시 말해 계수 정렬은 데이터의 크기가 한정되어 있고, 데이터의 크기가 많이 중복되어 있을수록 유리하며 항상 사용할 수는 없다. 계수 정렬의 공간 복잡도는 O(N + K)이다.
 
 ### 파이썬의 정렬 라이브러리
 정렬 알고리즘을 직접 작성하게 되는 경우도 있지만, 미리 만들어진 라이브러리를 이용하는 것이 효과적인 경우가 더 많다. 파이썬은 기본 정렬 라이브러리인 `sorted()` 함수를 제공한다. 퀵 정렬과 동작 방식이 비슷한 병합 정렬을 기반으로 만들어졌는데, 일반적으로 퀵 정렬보다는 느리지만 최악의 경우에도 시간 복잡도 O(NlogN)을 보장한다는 특징이 있다. `sorted()`나 `sort()`를 이용할 때에는 key 매개변수를 입력으로 받을 수 있다. key 값으로는 하나의 함수가 들어가야 하며 이는 정렬 기준이 된다.
 ```python
 array = [('바나나', 2), ('사과', 5), ('당근', 3)]

 def setting(data):
     return data[1]

 result = sorted(array, key=setting)
 ```
 #### 정렬 라이브러리의 시간 복잡도
 최악의 경우에도 시간 복잡도 O(NlogN)을 보장하며 이미 잘 작성된 함수이므로 직접 퀵 정렬을 구현할 때보다 더욱더 효과적이다. 문제에서 별도의 요구가 없다면 단순히 정렬해야 하는 상황에서는 기본 정렬 라이브러리를 사용하고, 데이터의 범위가 한정되어 있으며 더 빠르게 동작해야 할 때는 계수 정렬을 사용하자.
 1. **정렬 라이브러리로 풀 수 있는 문제:** 단순히 정렬 기법을 알고 있는지 물어보는 문제로 기본 정렬 라이브러리의 사용 방법을 숙지하고 있으면 어렵지 않게 풀 수 있다.
 2. **정렬 알고리즘의 원리에 대해서 물어보는 문제:** 선택 정렬, 삽입 정렬, 퀵 정렬 등의 원리를 알고 있어야 문제를 풀 수 있다.
 3. **더 빠른 정렬이 필요한 문제:** 퀵 정렬 기반의 정렬 기법으로는 풀 수 없으며 계수 정렬 등의 다른 정렬 알고리즘을 이용하거나 문제에서 기존에 알려진 알고리즘의 구조적인 개선을 거쳐야 풀 수 있다.
 ## 05. 이진 탐색
 ## 06. 다이나믹 프로그래밍
 ## 07. 최단 경로
 ## 08. 그래프 이론
