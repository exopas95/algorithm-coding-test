 # 알고리즘 코딩 테스트 준비 - Python

나동빈 저자의 "이것이 취업을 위한 코딩 테스트다"를 기반으로 작성된 문서입니다. 알고리즘에 대한 기본적인 설명은 위 책을 기반으로 기술되었습니다. 

 ## 01. 그리디
단순하지만 강력한 문제 해결 방법으로 어떤 문제가 있을 떄 단순 무식하게, 탐욕적으로 문제를 푸는 알고리즘이다. 여기서 그리디 즉, 탐욕이란 "현재 상황에서 지금 당장 좋은 것만 고르는 방법"을 의미한다.

그리디 알고리즘은 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구하며 현재 상황에서 가장 좋아보이는 것만을 선택해도 문제를 풀 수 있는지를 파악할 수 있어야 한다. 거스름돈 문제가 대표적인 그리디 문제이다.

 ## 02. 구현
 코딩테스트에서 구현이란 '머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정이다. 어떤 문제를 풀든 간에 소스코드를 작성하는 과정은 필수이므로 구현 문제 유형은 모든 범위의 코딩 테스트 문제 유형을 포함하는 개념이다.
 
 그렇다면 어떤 문제가 구현하기 어려운 문제일까? 알고리즘은 간단한데 코드가 지나칠 만큼 길어지는 문제, 특정 소수점 자리까지 출력해야 하는 문제 ,문자열이 입력으로 주어졌을 때 한 문자 단위로 끊어서 리스트에 넣어서 파싱을 해야하는 문제 등이 까다로운 구현 유형의 문제이다. 대체로 사소한 조건 설정이 많은 문제일수록 코드로 구현하기가 까다롭다.
 
 이 책에서 완전탐색과 시뮬레이션 유형을 모두 '구현'유형으로 묶어서 다루고 있다.
 - 완전탐색: 모든 경우의 수를 주저 없이 다 계산하는 해결 방법
 - 시뮬레이션: 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행해야하는 문제 유형
 
 ## 03. DFS/BFS
 DFS/BFS에 앞서서 기초적인 자료구조 스택과 큐, 그리고 재귀 함수에 대해서 알아봐야 한다.
 ### 탐색
 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정
 ### 자료구조
 데이터를 표현하고 관리하고 처리하기 위한 구조로 그중 스택과 큐는 자료구조의 기초개념으로 다음 **삽입(Push)**, **삭제(Pop)**으로 구성된다.
 ### 스택 (Stack)
 박스 쌓기에 비유할 수 있으며, 선입후출 또는 후입선출 구조라고 한다. 예를 들어 앞에서부터 a-b-c 순서로 입력이 됐다면 출력의 순서는 c-b-a의 순서이다. 파이썬에서는 스택을 위해서 별도의 모듈이 필요하지 않는다. 이미 주어진 append()와 pop() 매서드 만으로 스택을 구현할 수 있다.
 ### 큐 (Queue)
 대기 줄에 비유할 수 있으며, 선입선출 구조라고 한다. 예를 들어 a-b-c- 순서로 입력이 됐다면 출력의 순서 또한 a-b-c 이다. 파이썬에서 큐를 사용하기 위해서는 collections 모듈에서 제공하는 deque 자료구조를 활용하자. deque는 스택과 큐의 장점을 모두채택한 것인데 데이터를 넣고 뺴는 속도가 리스트 자료형에 비해 효율적이며 queue 라이브러리를 이용하는 것보다 더 간단하다.
 ### 재귀함수
 자기 자신을 다시 호출하는 함수로 종료 조건을 꼭 명시해줘야 한다. 재귀함수는 수학에서의 점화식을 그대로 표현한 형식이기 때문에 반복문에 비해서 더 간단하다. 
   - n이 0 혹은 1일때: factorial(n) = 1
   - n이 1 보다 클 때: factorial(n) = n * factorial(n - 1)
 ### 그래프
 노드와 엣지로 구조를 표현하는 방법
   - **인접 행렬 방식**: 2차원 행렬에 각 노드가 연결된 형태를 기록하는 방식
   - **인접 리스트 방식**: 연결된 노드에 대한 정보를 차례대로 연결하여 리스트에 기록하는 방식
   - **차이**: 메모리 측면에서 인접행렬 방식은 모든 관계를 저장하므로 노드 개수가 많을수록 메모리가 불필요하게 낭비된다. 반면 인접 리스트는 연결된 정보만을 저장하기에 효율적이다. 하지만 인접 리스트 방식은 특정한 두 노드가 연결되어 있는지에 대한 정보 하나씩 확인해야 되기 때문에 얻는 속도가 느리다. 특정한 노드와 연결된 모든 인접 노드를 순회해야 하는 경우, 인접 리스트 방식이 인접 행렬 방식에 비해 메모리 공간의 낭비가 적다.  
 ### DFS(Depth First Search)
 깊이 우선 탐색이라고 부르며, 그래프에서 깊은 부분을 우선적으로 탐색하는 방법이다.  
   - 스택의 자료구조를 사용한다.
 #### 동작과정
 1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다.
 2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면, 그 노드를 스택에 넣고 방문 처리를 한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.
 3. 2번의 과정을 더 이상 수행할 수 없을 때 까지 반복한다.
```python
# DFS 메서드 정리
def dfs(grapyh, v, visited):
    # 현재 노드를 방문 처리
    visitied[v] = True
  
    # 현재 노드와 연결된 다른 노드를 재귀적으로 방문
    for i in graph[v]:
        if not visitied[i]:
            dfs(graph, i, visited)
```
 ### BFS(Breadth First Search)
 너비 우선 탐색이라고 부르며, 가까운 노드부터 탐색하는 알고리즘이다.
   - 큐 자료구조를 사용한다.
 #### 동작과정
 1. 탐색 시작 노드를 큐에 삽입하고 방문처리를 한다.
 2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리를 한다.
 3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.
 ```python
 # BFS 메서드 정리
 def bfs(graph, start, visitied):
    # 큐(Queue) 구현을 위해 deque 라이브러리 사용
    queue = deque([start])
    
    # 현재 노드를 방문 처리
    visitied[start] = True

    # 큐가 빌 때가지 반복
    while queue:
        # 큐에서 하나의 원소를 뽑기
        v = queue.popleft()
        
        # 해당 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입
        for i in graph[v]:
            if not visitied[i]:
            queue.append(i)
            visitied[i] = True
 ```
 ## 04. 정렬
 정렬이란 데이터를 특정한 기준에 따라서 순서대로 나열하는 것을 말한다. 정렬 알고리즘은 이진 탐색의 전처리 과정으로 내림차순, 혹은 오름차순으로 정렬을 해야 이진 탐색을 적용할 수 있기 때문에 정렬 알고리즘을 잘 아는 것은 매우 중요하다. 여기서는 선택 정렬, 삽입 정렬, 퀵 정렬, 계수 정렬과 함께 파이썬에서 정렬에 어떤 라이브러리를 사용해야하는 지를 다룬다.
 ### 선택 정렬
 **가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복**하는 정렬로 '매번 가장 작은 것을 선택'한다는 의미에서 선택 정렬 알고리즘이라고 한다.
 ```Python
for i in range(len(array)):
    min_index = i

    for j in range(i + 1, len(array)):
        if array[min_index] > array[j]:
            min_index = j
            
    array[i], array[min_index] = array[min_index], array[i]  # 파이썬은 이런 식으로 Swap이 가능
 ```
 #### 선택 정렬의 시간 복잡도
 선택 정렬은 N - 1번 만큼 가장 작은 수를 찾아서 맨 앞으로 보내야 한다. 또한 매번 가장 작은 수를 찾기위해서 비교연산이 필요하다. 따라서 연산 횟수는 N + (N - 1) + (N - 2) + ... + 2로 볼 수 있다. 이것의 근사치는 N * (N + 1) / 2번으로 빅오 표기법으로 간단히 O(N<sup>2</sup>)이라고 표현할 수 있다.
 ### 삽입 정렬
 **데이터를 하나씩 확인하며, 각 데이터를 적절한 위치에 삽입하는 방법**으로 선택 정렬에 비해 실행 시간 측면에서 더 효율적인 알고리즘이다. 특히 필요할 때만 위치를 바꾸기 때문에 '데이터가 거의 정렬되어 있을 때' 훨씬 효율적이다. 삽입 정렬은 항상 오름차순을 유지하고 있으므로 삽입하려는 데이터가 자기보다 작은 데이터를 만났다면, 더 이상 데이터를 살펴볼 필요없이 그 자리에 삽입하면 된다.
 ```python
 for i in range91, len(array)):
    for j in range(i, 0, -1):   # 인덱스 i부터 1까지 감소하며 반복하는 문법
        if array[j] < array[j - 1]:   # 한 칸씩 왼쪽으로 이동
            array[j], array[j - 1] = array[j - 1], array[j]
        else:   # 자기보다 작은 데이터를 만나면 그 위치에서 멈춤
            break
```
#### 삽입 정렬의 시간 복잡도
삽입 정렬도 반복문이 2번 중첩되어 사용되었기에 시간 복잡도는 O(N<sup>2</sup>)이다. 하지만 현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작한다는 점을 기억해야 한다. 따라서 최선의 경우 O(N)의 시간 복잡도를 가진다. 정렬이 거의 되어 있는 상황에는 아래 있는 퀵 정렬보다 더 효율적이기도 하다.
 ### 퀵 정렬
 **기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법**으로 가장 많이 쓰이는 정렬 알고리즘이다. 기준을 설정한 다음 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작한다. 퀵 정렬에서는 *피벗(Pivot)*\이 사용되는데, 큰 숫자와 작은 숫자를 교환할 때, 교환하기 위한 기준을 피벗이라고 한다. 피벗을 설정하고 리스트를 분할하는 방법에 따라 여러 가지 방식으로 퀵 정렬을 구분하는데, 여기서는 가장 댇표적인 분할 장식인 호어 분할(Hoare Partition)방식을 기준으로 퀵 정렬을 설명한다. 
 - 호어 분할 방식: 리스트에서 첫 번째 데이터를 피벗으로 정한다.
 #### 전통적인 퀵 정렬 방식
 ```python
 def quick_sort(array, start, end):
    if start >= end:    # 원소가 1개인 경우 종료
        return
    pivot = start    # 피벗은 첫 번째 원소
    left = start + 1
    right = end

    while left <= right:
        # 피벗보다 큰 데이터를 찾을 때까지 반복
        while left <= end and array[left] <= array[pivot]:
            left += 1
        
        # 피벗보다 작은 데이터를 찾을 때까지 반복
        while right > start and array[right] >= array[pivot]:
            right -= 1

        # 엇갈렸다면 작은 데이터와 피벗을 교체
        if left > right:
            array[right], array[pivot] = array[pivot], array[right]
        
        # 엇갈리지 않았다면 작은 데이터와 큰 데이터를 교체
        else:
            array[left], array[right] = array[right], array[left]
        
    # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
    quick_sort(array, start, right - 1)
    quick_sort(array, right + 1, end)
 ```
 #### 파이썬의 장점을 살린 퀵 정렬 방식
 전통 퀵 정렬의 분할 방식과 조금 다르며 피벗과 데이터를 비교하는 비교 연산 횟수가 증가해서 시간 면에서는 조금 비효율적이다. 하지만 더 직관적이고 기억하기 쉽다는 장점이 있다.
 ```python
 def quick_sort(array):
    # 리스트가 하나 이하의 원소만을 담고 있다면 종료
    if len(array) <= 1:
        return array
    
    pivot = array[0]
    tail = array[1:]

    left_side = [x for x in tail if x <= pivot]
    right_side = [x for x in tail if x > pivot]

    # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬을 수행하고, 전체 리스트를 반환
    return quick_sort(left_side) + [pivot] + quick_sort(right_side)
 ```
 #### 퀵 정렬의 시간 복잡도
 앞서 배운 선택 정렬과 삽입 정렬은 최악의 경우에도 항상 시간 복잡도 O(N<sup>2</sup>)을 보장한다. 퀵 정렬의 평균 시간 복잡도는 O(NlogN)이다. 먼저 최선의 경우를 생각해보자. 피벗값의 위치가 변경되어 분할이 일어날 때마다 정확히 왼쪽 리스트와 오른쪽 리스트를 절반씩 분할한다면 데이터의 개수(가로 길이)에 비해 분할하는 횟수(세로 길이)는 약 log~2이다. 데이터가 무작위인 경우 퀵 정렬은 빠르게 동작할 확률이 높지만 만약 데이터가 이미 정렬이 되어있다면 퀵 정렬은 매우 느리게 동작한다. 
 ### 계수 정렬
 계수 정렬 **가장 큰 데이터와 가장 작은 데이터의 범위가 모두 담길 수 있도록 하나의 리스트를 생성한 뒤 데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스의 데이터를 1씩 증가시키면서 정렬하는 방식**이다. 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 알고리즘으로 최악의 경우에도 수행 시간 O(N + K)를 보장한다. 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때만 사용할 수 있으며 데이터의 값이 무한한 범위를 가질 수 있는 실수형 데이터가 주어지는 경우 계수 정렬은 사용하기 어렵다. 또한 일반적으로 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않을 때 효과적으로 사용할 수 있다.
 ```python
# 모든 원소의 값이 0보다 크거나 같다고 가정
# 모든 범위를 포함하는 리스트 선언(모든 값은 0으로 초기화)
count = [0] * (max(array) + 1)

for i in range(len(array)):
    count[array[i]] += 1

for i in range(len(count)):
    for j in range(count[i]):
        print(i, end= ' ')
 ```
 #### 계수 정렬의 시간 복잡도
 데이터의 개수를 N, 데이터 중 최댓값의 크기를 K라고 할 때, 계수 정렬의 시간 복잡도는 O(N + K)이다. 데이터의 범위만 한정되어 있다면 효과적으로 사용할 수 있으며 항상 빠르게 동작한다. 현존하는 정렬 알고리즘 중에서 기수 정렬(Radix Sort)와 더불어 가장 빠르다. 
 
 #### 계수 정렬의 공간 복잡도
 계수 정렬은 상황에 따라 심각한 비효율성을 초래한다. 예를 들어 데이터가 0과 999,999 단 2개만 존재할 경우 리스트의 크기가 100만개가 되도록 선언해야 한다. 따라서 항상 사용할 수 있는 정렬 알고리즘은 아니며, 동일한 값을 가지는 데이터가 여러 개 등장할 때 적합하다.
 다시 말해 계수 정렬은 데이터의 크기가 한정되어 있고, 데이터의 크기가 많이 중복되어 있을수록 유리하며 항상 사용할 수는 없다. 계수 정렬의 공간 복잡도는 O(N + K)이다.
 
 ### 파이썬의 정렬 라이브러리
 정렬 알고리즘을 직접 작성하게 되는 경우도 있지만, 미리 만들어진 라이브러리를 이용하는 것이 효과적인 경우가 더 많다. 파이썬은 기본 정렬 라이브러리인 `sorted()` 함수를 제공한다. 퀵 정렬과 동작 방식이 비슷한 병합 정렬을 기반으로 만들어졌는데, 일반적으로 퀵 정렬보다는 느리지만 최악의 경우에도 시간 복잡도 O(NlogN)을 보장한다는 특징이 있다. `sorted()`나 `sort()`를 이용할 때에는 key 매개변수를 입력으로 받을 수 있다. key 값으로는 하나의 함수가 들어가야 하며 이는 정렬 기준이 된다.
 ```python
 array = [('바나나', 2), ('사과', 5), ('당근', 3)]

 def setting(data):
     return data[1]

 result = sorted(array, key=setting)
 ```
 #### 정렬 라이브러리의 시간 복잡도
 최악의 경우에도 시간 복잡도 O(NlogN)을 보장하며 이미 잘 작성된 함수이므로 직접 퀵 정렬을 구현할 때보다 더욱더 효과적이다. 문제에서 별도의 요구가 없다면 단순히 정렬해야 하는 상황에서는 기본 정렬 라이브러리를 사용하고, 데이터의 범위가 한정되어 있으며 더 빠르게 동작해야 할 때는 계수 정렬을 사용하자.
 1. **정렬 라이브러리로 풀 수 있는 문제:** 단순히 정렬 기법을 알고 있는지 물어보는 문제로 기본 정렬 라이브러리의 사용 방법을 숙지하고 있으면 어렵지 않게 풀 수 있다.
 2. **정렬 알고리즘의 원리에 대해서 물어보는 문제:** 선택 정렬, 삽입 정렬, 퀵 정렬 등의 원리를 알고 있어야 문제를 풀 수 있다.
 3. **더 빠른 정렬이 필요한 문제:** 퀵 정렬 기반의 정렬 기법으로는 풀 수 없으며 계수 정렬 등의 다른 정렬 알고리즘을 이용하거나 문제에서 기존에 알려진 알고리즘의 구조적인 개선을 거쳐야 풀 수 있다.
 ## 05. 이진 탐색
 #### 순차 탐색
 리스트 안에 있는 특정한 데이터를 찾기 위해 앞에서부터 데이터를 하나씩 차례대로 확인하는 방법이다. 데이터의 개수가 N개일 때 최대 N번의 비교 연산이 필요하므로 순차 탐색의 최악의 경우 시간 복잡도는 O(N)이다.
 ```python
def sequential_search(n, target, array):
    # 각 원소를 하나씩 확인하며
    for i in range(n):

        # 현재의 원소가 찾고자 하는 원소와 동일한 경우
        if array[i] == target:

            # 현재의 위치를 반환한다
            return i + 1
 ```
 #### 이진 탐색 : 반으로 쪼개며서 탐색하기
 배열 내부의 데이터가 정렬되어 있어야만 사용할 수 있는 알고리즘으로 탐색 범위를 절반씩 좁혀가며 데이터를 탐색하는 특징이 있다. 이진 탐색은 위치를 나타내는 변수 3개를 사용하는데 탐색하고자 하는 범위의 시작점, 끝점 그리고 중간점이다. 찾으려는 데이터와 중간점 위치에 있는 데이터를 반복적으로 비교해서 원하는 데이터를 찾는다. 이진 탐색은 한 번 확인할 때마다 확인하는 원소의 개수가 절반씩 줄어든다는 점에서 시간 복잡도가 O(logN)이다. 이진 탐색 알고리즘은 한 단계를 거칠 때마다 확인하는 원소가 평균적으로 절반으로 줄어든다. 단계바다 2로 나누는 것과 동일하므로 연산 횟수가 log~2N 비례하기에 빅오 표기법에 따라서 간단히 O(logN)으로 표현한다.
 ##### 이진 탐색 - 재귀
 ```python
 def binary_serach(array, target, start, end):
    if start > end:
        return None
    mid = (start + end) // 2

    if array[mid] == target:
        return mid
    elif array[mid] > target:
        return binary_serach(array, target, start, mid - 1)
    else:
        return binary_serach(array, target, mid + 1, end)
 ```
 ##### 이진 탐색 - 반복
 ```python
 def binary_search(array, target, start, end):
    while start <= end:
        mid = (start + end) // 2

        if array[mid] == target:
            return mid

        elif array[mid] > target:
            end = mid - 1
        
        else:
            start = mid + 1
    
    return None
 ```
 #### 트리 자료구조
 노드와 노드의 연결로 표현하며 여기에서 노드는 정보의 단위로서 어떠한 정보를 가지고 있는 개체이다. 트리 자료구조는 그래프 자료구조의 일종으로 데이터베이스 시스템이나 파일 시스템과 같은 곳에서 많은 양의 데이터를 관리하기 위한 목적으로 사용한다. 트리 자료구조는 몇가지 주요한 특징이 있다.
 - 트리는 부모 노드와 자식 노드의 관계로 표현된다.
 - 트리의 최상단 노드를 루트 노드라고 한다.
 - 트리의 최하단 노드를 단말 노드라고 한다.
 - 트리에서 일부를 떼어내도 트리 구조이며 이를 서브 트리라고 한다.
 - 트리는 파일 시스템과 같이 계층적이고 정렬된 데이터를 다루기에 적합하다.
 #### 이진 탐색 트리
 트리 자료구조 중에서 가장 간단한 형태로 다음과 같은 특징을 지닌다.
 - 부모 노드보다 왼쪽 자식 노드가 작다.
 - 부모 노드보다 오른쪽 자식 노드가 크다.
 #### 빠르게 입력받기
 이진 탐색 문제는 시간이 짧아야 하는데 흔 히사용하는 input() 함수는 동작 속도가 느려서 시간 초과로 오답 판정을 받을 수 있다. 입력 데이터가 많은 문제는 `sys` 라이브러리의 `readline()` 함수를 이용하여 시간 초과를 피해보도록 하자.
 ```python
 import sys
 input_data = sys.stdin.readline().rstrip()
 ```
 
 ## 06. 다이나믹 프로그래밍
 다이나믹 프로그래밍은 **한 번 계산한 문제는 다시 계산하지 않도록하는 알고리즘**으로 메모리 공간을 약간 더 사용해서 연산 속도를 비약적으로
 증가시키는 방법이다. 다이나믹 프로그래밍의 대표적인 예로 피보나치 수열이 있다. 피보나치 수열을 재귀함수로 풀어보자.
 ```python
def fibo(x):
    if x == 1 or x == 2:
        return 1
    return fibo(x - 1) + fibo(x - 2)
 ```

 하지만 여기서 X의 값이 커지면 커질수록 수행 시간이 기하급수적으로 늘어난다. 위 피보나치 재귀함수의 빅오는 O(2<sup>n</sup>)이다.
 이처럼 피보나치 수열의 점화식을 재귀함수를 사용해서 만들 수는 있지만, 단순히 매번 계산하도록하면 문제를 효율적으로 해결할 수 없다.
 이러한 문제는 다이나믹 프로그래밍을 사용해야 효율적으로 해결할 수 있다. 다만 항상 다이나믹 프로그래밍을 사용할 수는 없으며 다음 조건을
 만족할 때 사용할 수 있다.
 1. 큰 문제를 작은 문제로 나눌 수 있다.
 2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

 이제 피보나치 수열을 **메모이제이션**기법을 사용해서 해결해보자. 메모이제이션은 다이나믹 프로그래밍을 구현하는 방법 중 한 종류로,
 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법을 의미한다.
 메모이제이션은 값을 저장하는 방법이므로 **캐싱**이라고도 한다.
 ```python
d = [0] * 100
def fibo(x):
    if x == 1 or x == 2:
         return 1
    # 이미 계산한 적 있는 문제라면 그대로 반환
    if d[x] != 0:
        return d[x]
    # 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
    d[x] = fibo(x - 1) + fibo(x - 2) 
 ```
 이렇듯 다이나믹 프로그래밍이란 큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법이다.
 다이나믹 프로그래밍의 시간 복잡도는 O(N)이다. 다이나믹 프로그래밍은 소스코드를 작성하는 방법에 따라 두 가지로 나뉜다.
 1. 탑다운 방식: 재귀 함수
 2. 바텀업 방식: 반복문

 위의 탑다운 방식의 피보나치를 바텀업으로 바꾸면 다음과 같다.
 ```python
d = [0] * 100
d[1] = 1
d[2] = 1
n = 99

for i in range(3, n+1):
    d[i] = d[i - 1] + d[i - 2]
 ```
 가능하면 시스템 오버헤드가 적은 바텀업 방식으로 다이나믹 프로그래밍을 구현하도록하자. 만약 탑다운 방식을 사용해야하고 시스템상 재귀 함수의 스택 크기가 한정되어 있다면 `sys` 라이브러리에 포함되어 있는 `setrecursionlimit()` 함수를 호출하여 재귀 제한을 완화하자.

 > 프로그래밍에서 다이나믹은 '프로그램이 실행되는 도중에'라는 의미이다. 예를 들어 자료구조에서 동적 할당(Dynamic Allocation)은 
   프로그래밍 실행 중에 프로그램 실행에 필요한 메모리를 할당하는 기법이다. 하지만 다이나믹 프로그래밍에서 다이나믹은 이런 의미가 아니다.
 ## 07. 최단 경로
 **최단 경로** 알고리즘은 말 그대로 가장 잛은 경로를 찾는 알고리즘이다. 최단 경로 문제는 보통 그래프를 이용하여 표현하는데 각 지점은 그래프에서 '노드'로 표현되고, 지점간 연결된 도로는
 '엣지'로 표현된다. 또한 실제 코딩테스트에서는 최당 경로를 모두 출력하는 문제보다는 단순히 최단 거리를 출력하도록 요구하는 문제가 많이 출제된다.
 컴퓨터공학과 학부 수준에서 사용하는 최단거리 알고리즘은 다익스트라 최단 경로 알고리즘, 플로이드 워셜, 벨만 포드 알고리즘, 이렇게 3개이다. 이 책에서는 대표적인 알고리즘인
 다익스트라 알고리즘과 플로이드 워셜 알고리즘 유형만 다룬다. 더불어 앞서 공부한 그리디 알고리즘과 다이나믹 프로그래밍 알고리즘이 최단 경로 알고리즘에 그대로 
 적용된다는 특징이 있어서 최단 경로 문제는 그리디 알고리즘 및 다이나믹 프로그래밍 알고리즘의 한 유형으로 볼 수 있다.
 
 ### 다익스트라 최단 경로 알고리즘
 다익스트라 최단 경로 알고리즘은 그래프에서 여러 개의 노드가 있을 때, 특정한 노드에서 출발하여 다른 노드로 가는 각각의 최단경로를 구해주는 알고리즘이다.
 다익스트라 최단 경로 알고리즘은 '음의 엣지'가 없을 때 정상적으로 동작하며 기본적으로 그리디 알고리즘으로 분류된다. 매번 '가장 비용이 적은 노드'를 선택해서 임의의 과정을 반복하기 때문이다.
 알고리즘의 원리는 아래의 순서와 같다.
 1. 출발 노드를 설정한다.
 2. 최단 거리 테이블을 초기화한다.
 3. 방문하지 않은 노드 중에서 쵣찬 거리가 가장 짧은 노드를 선택한다.
 4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다.
 5. 위 과정에서 3번과 4번을 반복한다.
 
 다익스트라 알고리즘은 최단 경로를 구하는 과정에서 각 노드에 대한 현재까지의 최단 거리 정보를 항상 1차원 리스트에 저장하여 리스트를 계속 갱신한다는 특징이 있다.
 매번 현재 처리하고 있는 노드를 기준으로 주변 엣지를 파악한다. 따라서 방문하지 않은 노드 중에서 현재 최단 거리가 가장 짧은 노드를 확인해 그 노드에 대하여
 4번 과정을 수행한다는 점에서 그리디 알고리즘으로 볼 수 있다.
 
 다익스트라 알고리즘에서는 '방문하지 않은 노드 중에서 가장 최단 거리가 짧은 노드를 선택'하는 과정을 반복하는데 이렇게 선택된 노드는 '최단 거리'가 완전히 선택된 노드이므로,
 더 이상 알고리즘을 반복해도 최단거리가 줄지 않는다. 다시 말해 다익스트라 알고리즘이 진행되면서 **한 단계당 하나의 노드에 대한 최단 거리를 확실히 찾는 것**으로 이해할 수 있다.

 #### 1. 간단한 다익스트라 알고리즘
 간단한 다익스트라 알고리즘은 O(V<sup>2</sup>)의 시간 복잡도를 가지며, 다익스트라에 의해서 처음 고안되었던 알고리즘이다. V는 노드의 개수를 의미한다.
 1. 처음에 각 노드에 대한 최단 거리를 담는 1차원 리스트를 선언한다.
 2. 단계마다 '방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택'하기 위해 매 단계마다 1차원 리스트의 모든 원소를 순차 탐색 한다.
 ```python
 import sys
input = sys.stdin.readline
INF = int(1e9)

# 노드의 개수, 간선의 개수를 입력받기
n, m = map(int, input().split())

# 시작 노드 번호를 입력 받기
start = int(input())

# 각 노드에 연결되어 있는 노드에 대한 정보를 담는 리스트를 만들기
graph = [[] for i in range(n + 1)]

# 방문한 적이 있는 노드에 대한 정보를 담는 리스트를 만들기
visitied = [False] * (n + 1)

# 최단 거리 테이블을 모두 무한으로 초기화
distance = [INF] * (n + 1)

# 모든 간선 정보를 입력받기
for _ in range(m):
    a, b, c, = map(int, input().split())
    # a번 노드에서 b번 노드로 가는 비용이 c라는 의미
    graph[a].append((b, c))

# 방문하지 않은 노드 중에서, 가장 최단 거리가 짧은 노드의 번호를 반환
def get_smallest_node():
    min_value = INF
    index = 0   # 최단 거리가 가장 짧은 노드
    for i in range(1, n + 1):
        if distance[i] < min_value and not visitied[i]:
            min_value = distance[i]
            index = i
    return index

def dijkstra(start):
    # 시작 노드에 대해서 초기화
    distance[start] = 0
    visitied[start] = True

    for j in graph[start]:
        distance[j[0]] = j[1]

    # 시작 노드를 제외한 전체 n - 1개의 노드에 대해 반복
    for i in range(n - 1):

        # 현재 최단 거리가 가장 짧은 노드를 꺼내서, 방문 처리
        now = get_smallest_node()
        visitied[now] = True
        
        # 현재 노드와 연결된 다른 노드를 확인
        for j in graph[now]:
            cost = distance[now] + j[i]
            
            # 현재 노드를 거쳐서 다른 노드로 이동하는 거리가 더 짧은 경우
            if cost < distance[j[0]]:
                distance[j[0]] = cost
    
# 다익스트라 알고리즘 수행
dijkstra(start)

# 모든 노드로 가기 위한 최단 거리를 출력
for i in range(1, n + 1):
    # 도달할 수 없는 경우, 무한이라고 출력
    if distance[i] == INF:
        print("INFINITY")
    else:
        print(distance[i])
 
 ```
 시간복잡도가 O(v<sup>2</sup>)이기 때문에 노드의 개수가 5,000개 이하라면 이 코드로 풀 수 있지만 노드의 개수가 10,000개를 넘어가는 문제라면 아래의
 개선된 다익스트라 알고리즘을 적용해야 한다.
 #### 2. 개선된 다익스트라 알고리즘
 개선된 다익스트라 알고리즘의 시간 복잡도는 O(ElogV)를 보장하며 여기서 V는 노드의 개수, E는 엣지의 개수를 의미한다.
 간단한 다익스트라 알고리즘은 최단 거리가 가장 짧은 노드를 찾기 위해서 매번 최단 거리 테이블을 선형적으로 탐색해야 했고 이 과정에서 O(V)의 시간이 걸렸다.
 개선된 다익스트라 알고리즘에서는 힙 자료구조를 사용한다. 힙 자료구조를 이용하게 되면 특정 노드까지의 최단 거리에 대한 정보를 힙에 담아서 처리하므로
 출발 노드로부터 가장 거리가 짧은 노드를 더욱 빠르게 찾을 수 있다.
 
 파이썬에서는 우선순위 큐가 필요할 때 `PriorityQueue` 혹은 `heapq`를 사용할 수 있는데 일반적으로 `heapq`가 더 빠르게 동작하기 때문에 이를 사용하도록 하자.
 우선순위 큐를 구현할 때는 내부적으로 최소 힙과 최대 힙을 이용하는데, 비용이 적은 노드를 우선하여 방문하므로 최소 힙 구조를 기반으로 파이썬의 우선순위 큐 라이브러리를 사용하면 적합하다.
 혹은 최소 힙을 최대 힙처럼 사용하기 위해서 일부러 우선순위에 해당하는 값에 음수 부호(-)를 붙여서 넣었다가 나중에 우선순위 큐에서 꺼낸 다음에 
 다시 음수 부호(-)를 붙여서 원래의 값으로 돌리는 방식을 사용할 수도 있다.
 이제 우리는 우선순위 큐를 이용해서 시작 노드로부터 거리가 짧은 노드 순서대로 큐에서 나올 수 있도록 다익스트라 알고리즘을 작성할 것이다.
 앞의 코드와 비교했을 때 get_smallest_node()라는 함수를 작성할 필요가 없다는 특징이 있다.
 **최단 거리가 가장 짧은 노드를 선택하는 과정을 다익스트라 최단 경로 함수 안에서 우선순위 큐를 이용하는 방식으로 대체할 수 있기 때문이다.**
 ```python
 import heapq
import sys
input = sys.stdin.readline
INF = int(1e9)

# 노드의 개수, 간선의 개수를 입력받기
n, m = map(int, input().split())

# 시작 노드 번호를 입력 받기
start = int(input())

# 각 노드에 연결되어 있는 노드에 대한 정보를 담는 리스트를 만들기
graph = [[] for i in range(n + 1)]

# 방문한 적이 있는 노드에 대한 정보를 담는 리스트를 만들기
visitied = [False] * (n + 1)

# 최단 거리 테이블을 모두 무한으로 초기화
distance = [INF] * (n + 1)

# 모든 간선 정보를 입력받기
for _ in range(m):
    a, b, c, = map(int, input().split())
    # a번 노드에서 b번 노드로 가는 비용이 c라는 의미
    graph[a].append((b, c))


def dijkstra(start):
    q = []

    # 시작 노드로 가기 위한 최단 경로는 0으로 설정하여, 큐에 삽입
    heapq.heappush(q, (0, start))
    distance[start] = 0
    visitied[start] = True

    # 큐가 비어있지 않다면
    while q:
        # 가장 최단 거리가 짧은 노드에 대한 정보 꺼내기
        dist, now = heapq.heappop(q)

        # 현재 노드가 이미 처리된 적이 있는 노드라면 무시
        if distance[now] < dist:
            continue
        
        # 현재 노드와 연결된 다른 노드를 확인
        for i in graph[now]:
            cost = distance[now] + i[i]
            
            # 현재 노드를 거쳐서 다른 노드로 이동하는 거리가 더 짧은 경우
            if cost < distance[i[0]]:
                distance[i[0]] = cost
                heapq.heappush(q, (cost, i[0]))
    
# 다익스트라 알고리즘 수행
dijkstra(start)

# 모든 노드로 가기 위한 최단 거리를 출력
for i in range(1, n + 1):
    # 도달할 수 없는 경우, 무한이라고 출력
    if distance[i] == INF:
        print("INFINITY")
    else:
        print(distance[i])
 ```
 ### 플로이드 워셜 알고리즘
 다익스트라 알고리즘이 '한 지점에서 다른 특정 지점까지의 최단 경로를 구해야 하는 경우'에 사용할 수 있는 최단 경로 알고리즘이라면,
 플로이드 워셜 알고리즘은 '모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야 하는 경우'에 사용할 수 있는 알고리즘이다.
 플로이드 워셜 알고리즘 또한 다익스트라 알고리즘과 유가하게 단계마다 '거쳐 가는 노드'를 기준으로 알고리즘을 수행한다.
 하지만 매번 방문하지 않은 노드 중에서 최단 거리를 갖는 노드를 찾을 필요가 없다는 점이 다르다.
 노드의 개수가 N개일 때 알고리즘상으로 N번의 단계를 수행하며, 단계마다 O(N<sup>2</sup>)의 연산을 통해 '현재 노드를 거쳐가는' 모든 경로를 고려한다.
 따라서 플로이드 워셜 알고리즘의 총시간 복잡도는 O(N<sup>3</sup>)이다.
 다익스트라 알고리즘에서는 출발 노드가 1개이므로 1차원 리스트를 사용했다면, 플로이드 워셜 알고리즘은 모든 노드에 대하여 다른 모든 노드로가는 최단 거리 정보를 담아야 하기에 2차원 리스트를 사용한다.
 다익스트라 알고리즘은 그리디 알고리즘인데 반해 플로이드 워셜 알고리즘은 다이나믹 프로그래밍이라는 특징이 있다. 
 노드의 개수가 N이라고 할 때, N번 만큼의 단계를 반복하여 '점화식에 맞게' 2차원 리스트를 갱신하기 때문이다.
 
 각 단계에서는 해당 노드를 거쳐 가는 경우를 고려한다. 예를 들어 1번 노드에 대해서 확인할 때는 1번 노드를 중간에 거쳐 지나가는 모든 경우를 고려하면 된다.
 정확히는 A -> 1번노드 -> B로 가는 비용을 확인한 후에 최단 거리를 갱신한다. 이를테면 현재 최단 거리 테이블에 A번 노드에서 B번 노드로 이동하는 비용이 3으로 기록되었을 때,
 A번 노드에서 1번 노드를 거쳐 B번 노드로 이동하는 비용이 2라는 것이 밝혀지면, A번 노드에서 B번 노드로 이동하는 비용을 2로 갱신하는 것이다.
 따라서 알고리즘에서는 현재 확인하고 있는 노드를 제외하고 N - 1개의 노드 중에서 서로 다른 노드 (A, B)쌍을 선택한다.
 이후에 A -> 1번 노드 -> B로 가는 비용을 확인한 뒤에 최단 거리를 갱신한다. 다시 말해 <sub>N-1</sub>P<sub>2</sub>개의 쌍을 단계마다 반복해서 확인하면 된다. 
 이때 O(<sub>N-1</sub>P<sub>2</sub>)는 O(N<sup>2</sup>)이라고볼 수 있기 때문에 전체 시간 복잡도는 O N(N<sup>3</sup>)이다.
 구체적인 점화식은 다음과 같다.
 
 
 <div align="center">
   <br>
   D<sub>ab</sub> - min(D<sub>ab</sub>, D<sub>ak</sub> + D<sub>kb</sub>)
 </div>
 <br>
 <br>
 
 따라서 전체적으로 3중 반복문을 이용하여 이 점화식에 따라 최단거리 테이블을 갱신하면 된다. 위 점화식을 말로 풀어 설명하자면
 A에서 B로가는 최소 비용과 A에서 K를 거쳐 B로가는 비용을 비교하여 더 작은 값으로 갱신하겠다는 것이다. 즉, '바로 이동하는 거리가'가 
 '특정한 노드를 거쳐서 이동하는 거리'보다 더 많은 비용을 가진다면 이를 더 짧은 것으로 갱신한다는 것이다.
 소스코드는 다음과 같다.
 ```python
 INF = int(1e9)

# 노드의 개수 및 간선의 개수를 입력받기
n = int(input())
m = int(input())

# 2차원 리스트(그래프 표현)을 만들고, 모든 값을 무한으로 초기화
graph = [[INF] * (n + 1) for _ in range(n + 1)]

# 자기 자신에서 자기 자신으로 가는 비용은 0으로 초기화
for a in range(1, n + 1):
    for b in range(1, n + 1):
        if a == b:
            graph[a][b] = 0

# 각 간선에 대한 정보를 입력받아, 그 값으로 초기화
for _ in range(m):
    # A에서 B로 가는 비용은 C라고 설정
    a, b, c = map(int, input().split())
    graph[a][b] = c

# 점화식에 따라 플로이드 워셜 알고리즘 수행
for k in range(1, n + 1):
    for b in range(1, n + 1):
        # 도달할 수 없는 경우 무한이라고 출력
        if graph[a][b] == INF:
            print("INFINITY", end= " ")
        else:
            print(graph[a][b], end=" ")
 ```
 ## 08. 그래프 이론
 ### 이미 배운 내용 훑기
 이번 장에서는 지금까지 다루지 않았던 그래프 알고리즘을 추가로 다룬다. 하지만 모든 내용은 앞장에 배운 내용을 기반으로 한다. 예를 들어 크루스칼 알고리즘은 그리디 알고리즘으로 분류되며
 위상 정렬 알고리즘은 큐 자ㅏ료구조 혹은 스택 자료구조를 활용한다. 먼저 그래프 구현 방법 두 가지를 살펴보고 들어가보도록 하자.
 - 인접 행렬: 2차원 배열을 사용하는 방식
 - 인접 리스트: 리스트를 사용하는 방식
 2가지 모두 그래프 알고리즘에서 매우 많이 사용되며 메모리와 속도 측면에서 차이가 난다. 노드의 개수가 V, 간선의 개수가 E인 그래프인 경우를 생각해보자.
 인접 행렬 방식은 간성정보를 저장하기 위해 O(V<sub>2)만큼의 메모리 공간이 필요하며, 인접 리스트방식은 간선의 개수인만큼인 O(E)만큼 메모리 공간이 필요하다.
 또한 인접 행렬은 특정한 노드 A에서 다른 노드 B로 이어진 간선의 비용을 O(1)의 시간으로 즉시 알 수 있다는 장점이 있으며,
 반면에 인접 리스트를 이용할 때는 O(V)만큼 시간이 소요된다.
 
 9장에서 다익스트라 최단 경로 알고리즘은 인접 리스트를 사용하였으며 플로이드 워셜 알고리즘은 인접 행렬을 이용하는 방식이었다. 여기서 알아두어야 할 점은 어떤 문제를
 만나든 메모리와 시간을 염두에 두고 알고리즘을 선택해서 구현해야 하는 것이다. 예를 들어 최단 경로를 찾아야 하는 문제가 출제되었을 때, 노드의 개수가 적은 경우에는
 플로이드 워셜 알고리즘을 이용할 수 있다. 반면에 노드와 간선의 개수가 모두 많으면 우선순위 큐인 다익스트라 알고리즘을 이용하면 유리하다.
 
 ### 서로소 집합
 수학에서 서로소 집합이란 공통 원소가 없는 두 집합을 의미한다. 서로소 집합 자료구조는 몇몇 그래프 알고리즘에서 매우 중요하게 사용되므로 그래프 알고리즘 이론 전에 설명한다.
 서로소 집합 자료구조란 **서로소 부분 집합들로 나누어진 원소들의 데이터를처리하기 위한 자료구조**이며 다음 두 연산으로 조작한다.
 - union: 2개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산
 - find: 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산이다.
 서로소 집합 자료구조는 합집합과 찾기 연산으로 구성되어 union-find 자료구조 라고 불리기도 한다.
